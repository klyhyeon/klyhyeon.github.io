---
layout: post
title: 2023 우아콘(우아한테크콘퍼런스) 참여 후기
image: 
  path: /assets/img/blog/woowacon-2023.png
#description: >
#  Version 9 is the most complete version of Hydejack yet.
#  Modernized design, big headlines, and big new features.
sitemap: false
---

2023 우아한테크콘퍼런스 참여후기
{:.lead}

첫 번째 우아콘에 참여하고 왔습니다. 컨퍼런스로는 지난 봄 2023 스프링 캠프 이후로 두번째네요. 주변에 다들 떨어지고 혼자돼 아쉽지만 기쁜 마음으로 다녀왔습니다.

우선 회사 애플리케이션 코드 단에서 Command-Query(CQRS)를 쓰고 있는데 이를 기반으로 MQ 이벤트 주도 아키텍처 경험들을 들을 수 있어 이해도가 높았고, 모놀리식 아키텍처를 MSA로 점진적 분리하는 세션은 추후 아키텍처를 변경할 때 참고할 수 있어 백엔드 세션 만족도도 높았습니다. 

백엔드 분야 외에도 `PM(수기 업무 자동화 세션)`과 `문화(이벤트 스토밍 소개 세션)` 분야를 들었는데 수확이 있었습니다. 
스타트업에선 특히 기획이 개발자에게 전달될 때, 빠진 부분은 없는지 디테일하게 확인하는 부분이 필요하며, 타 팀 혹은 팀 내에서 같은 도메인을 다르게 커뮤니케이션 하는 문제가 생길 때 적용해볼 수 있는 팁들을 챙길 수 있었습니다. 

들은 세션들 중 비교적 메모를 잘 했던 것만 아주 간단히(대충) 남겨보았습니다. (_실제 내용과 다를 수 있습니다!!_)

- Table of Contents
{:toc .large-only}

## 1. 대규모 트랜잭션을 처리하는 배민 주민시스템 규모에 따른 진화 - 강홍구(푸드주문서버개발팀)

### 성장하는 배민 주문 시스템(시스템의 성장과 함께 기술적인 문제가 발생하죠)

일 주문건수 2018(약 30만) -> 2023(약 350만)
- 단일 장애 포인트가 전체 시스템의 장애로 이어짐
- 대용량 데이터 - RDBMS 조인 연산으로 조회 성능 좋지 않음
- 대규모 트랜잭션 - 주문수 증가로 저장소의 분당 쓰기 처리량 한계에 도달
- 복잡한 이벤트 아키텍처 - 규칙 없는 이벤트 발행으로 유실되는 이벤트 많아지고 서비스 복잡도 높아짐

### 단일 장애 포인트

MQ 이용한 MSA 
- 문제: 중앙 집중 DB의 장애가 전체 시스템으로 번짐
- MQ로 이벤트 기반 아키텍처 사용. MQ 지연돼도 MQ 재소비가 가능하기에 지연을 줄임

## 대용량 데이터

- 주문내역 상세에 정말 많은 데이터가 필요함
- 주문 애그리거트 기술로 조인 연산이 필요했고, 해결하기 위해 MongoDB를 이용해 애그리거트, 역정규화로 테이블을 MongoDB의 도큐먼트 하나로 묶음
- 결국 커맨드 모델과 조회 모델을 분리하고 조회 모델 역 정규화를 통해 해결

## 대규모 트랜잭션

CQRS 형태의 DB 구조
- 스펙업 때문에 수용할 수 있는 용량의 클라우드 DB가 없음(?) 

해결책은 샤딩
- 샤드 클러스터를 구성해 쓰기 부하를 분한
- 코드 단에서 애플리케이션 샤딩을 구현하자
- 데이터 저장 시 어떤 샤드에 접근할지 결정하는 샤딩전략 고민
- 여러 샤드에 있는 데이터를 애그리게이트 하는 방법에 대한 고민

샤딩 전략
- key Based
    - hash based 주문번호를 Hash function을 돌려서 나온 해시 값으로 샤드에 이어줌(주문 A - 해시값 1 - 샤드 1)
    - 구현 간단, 샤드 클러스터 , 데이터 동적으로 재배치할 때 샤드 변경
- Range based sharding
  - 주문 가격 기반으로 샤딩함
  - 특정 값의 범위 기반(5천원~1만원)으로 샤드를 결정하면 돼서 구현이 간단
  - 데이터가 균등하게 배분되지 않아 특정 샤드에 부하가 될 수 있음
- Directory Based
  - Key based와 유사한데 룩업 테이블이 있음
  - 동적으로 샤드를 추가하는데 유리
  - 룩업 테이블이 단일 장애 포인트가 될 수 있음

주문 시스템의 특징
- 주문이 정상 동작하지 않으면 배민 전체 서비스의 좋지 않은 경험이 된다 -> 단일 장애 포인트는 피함
- `동적` 주문 데이터는 최대 30일 만 저장한다. -> 샤드 추가 이후 30일이 지나면 데이터는 다시 균등하게 분배된다.
- 결정은 Key Based 샤딩
주문 순번 % 샤드 수 = 샤드번호
- 주문번호 샤드 키를 사용해 균등 분배

## 복잡한 이벤트 아키텍처

이벤트 처리 주체의 단일화
- 도메인은 도메인 이벤트만 발행, 이벤트 스냅샷 (SQS) -> 이벤트 

이벤트 발행 실패 유형
- 트랜잭션 안에서 이벤트 발생 실패: 도메인 로직 전체가 실패(이슈 없음)
- 도메인 로직은 성공 이벤트 발생 실패로 서비스 로직 재실행 못함
트랜잭션 아웃박스 패턴
- 이벤트 발생 실패와 서비스 실패를 격리하여 재발행 수단을 보장
서비스 로직 -> 아웃박스 -> 이벤트 publish
- 이벤트 유실이 발생해서 이벤트 퍼블리시가 아웃박스를 통해 payload를 재소비


## 2. 모놀리식에서 점진적 서비스 분리: 사업과제와 병행하여 시스템 개선하기 - 손민성, 윤미현(배민상회개발팀)

### 비즈니스의 성장은 모놀리식 (500K 라인 코드의 압박)

- 복잡도가 너무 큼
- 장애가 다른 시스템 영향을 끼침
- 빌드 시간에 너무 오래걸림
  - 유닛 테스트에 빌드 3분
  - 부트스트랩 시간 2분
- 설계가 좋지 않으면 기능 제공 속도가 점점 느려짐

### 빌드/개발 단위 작게 만들기

- 개발단위가 작을수록 도메인간 결합도가 작다. 봐야하는 코드도 적어짐
- 빌드단위가 클수록 시간이 오래 걸림, 작으면 빌드 시간도 단축

### 컴포넌트 분리

- 모놀리식을 컴포넌트로 나눔
- 모듈이든 서비스든 컴포넌트로 나눈다는 것임
- 어떤 기준으로 나눠야할까?
  - 여러 팀이 함께 일함. 회원/주문/상품 도메인별로 경계가 생김
  - 도메인 단위로 컴포넌트를 나눴음
- 분리하는 과정에서 일정상, 진행 중인 사업과제가 있기 때문에 한번에 분리하기가 힘듦

### 서비스 분리하기

- 도메인 컴포넌트별로 점진적 분리를 시작함 (회원 도메인부터)
- 코드의 변화를 적게 가져갈 수 있는 분리가 뭘까?
  - 1차적으로 모듈로 분리한다.
  - 도메인 모듈: 여러 도메인 로직이 준재하는 모듈
  - 양방향 의존성 제거:
    - OrderService, GoodsService <-> MemberOrderService
      - ~~단방향 의존성으로 리팩토링~~ -> 코드 변경이 너무 많아서 힘듦
      - 상위 수준 모듈과 하위 수준 모듈은 둘 다 추상화에 의존해야 한다. 의존 역전 원칙(DIP)
      - 인터페이스 분리 (인터페이스를 의존함) OrderServiceiterface, MemberServiceinterface (클린 아키텍처 책에서 SRP 설명할 때 나온 방법과 유사)
- 인터페이스의 위치
  - 멤버 모듈에 위치: 멤버 서비스에만 있어야 하는 서비스 로직이 도메인 모듈에 영향을 미칠 수 있음
  - 도메인 모듈에 위치: 빌드할 때 도메인 모듈이 영향을 미침
  - 멤버 인터페이스 모듈을 중간에 따로 두었음: dependency에서 runtimeOnly로 두어 런타임때에만 의존할 수 있도록 함
- 충돌 최소화 하기
  - 의존하고 있는 다른 도메인의 코드를 바꾸지 않아도 되게 인터페이스 클래스명을 기존과 같게 유지하고 영향을 미치지 않는 Impl하는 클래스명만 변경함(MemberService -> MemberServiceImpl)
- 서비스 분리는 트레이드 오프를 고려 (복잡성, 유지보수, 네트워크 통신비용)
- 기존 모놀리식 서비스 레포(ex. baeminmart)
  - api, batch, worker -> domain, member -> member-interface
- 분리(ex. baeminmart-member)
2. 기존 API 엔드포인트를 1:1로 만든다
- Interface(findbyId()) : Service(findById()) (1:1)
3. 네트워크 통신 호출로 변경 시에 고려해야할 점
  - 네트워크 통신 비용과 제약, 네트워크 실패, 지연 발생 가능(재시도 메커니즘), 너무 오래 걸리는 요청(작게 나눠서 병렬요청)
  - 동일 스레드, 인메모리 처리되던 로직이 다른 프로세스/머신에서 처리되는 변경
    - in-memory thread bound 데이터들 연결이 안됨
      - @Transactional, 로컬캐시, 스레드 로컬...etc
  - 사이클 제거하기
    - 컴포넌트들 간에 결합은 독립적인 개발, 배포를 어렵게 한다
    - domain <-> member 사이클에서, member -> domain 호출을 제거함
    - 제거하기: 조회성(query), 커맨드성(command)으로 분류
      - domain이 조회를 처리하고 인자로 member 서비스에 전달
      - 커멘드성은 MQ를 사용해 상호작용함

### 안전하게 배포하기
- 장애 발생 시 빠르게 롤백하기 위해 feature flag 도입
  - 코드 변경없이 특정 기능을 변경할 수 있다.
  - 예를 들어 flag - on yes 면 회원 API 호출 no면 기존 API 호출
  - 기존 레퍼에 featureFlag를 넣어서 feature flag를 온오프 변경할 수 있음
  - 장애가 나는 특정 서비스만 피처 오프
  - 모든 인스턴스에 적용되는 flag
  - spring config server와 MQ bus를 통해 run time에 장애가 발생했을 때 feature off로 돌려 특정 서비스만 롤백할 수 있었음

## 3. 어제보다 오늘을 조금 더 똑똑하고 편하게! 수기 업무 플로 자동화의 3가지 사례 - 박지선(라이더플랫폼팀 PM)

### 프로젝트의 진행 순서
- 배경/현황 분석: 왜 플젝을 실행해야하는지
- **목적 정의 ✅**
- 목표 구체화
- **상세 구현/내용 기획 ✅**
- 개발
- 테스트
- 배포
- **피드백 분석/후속 대응 ✅**

### 목적 정의

프로덕트는 왜 존재할까? (돈이 되는 서비스를 만들기 위해?) - 수익 창출, 공익적 목적, 사적인 목표...
-> 프로덕트는 `수단`이다

디자인, 사용성, 편리함... 전부 목적을 달성하기 위한 방법이지 이것 자체가 목적이 될 수는 없다

**Case01. 수수료 지급명세서 발급 자동화**
- 특정 기간의 배달 소득을 항목별로 확인할 수 있는 서류. 종소세 신고나 국가 지원금 수령에 필요함
- 만나는 고민들: '지금도 운영되고 있으니까', '사업의 성장목표가 더 중요하니까', '당장 급하지 않으니까'
- 수기로 인한 실수. 개인정보가 담긴 서류임. 메일 발송을 잘못하면 어떡하지.
- as-is 운영자 리소스 절감 -> 코스트 감소, 운영자의 업무 만족도 증가 --> to-be 개인정보 노출로 인한 사업 리스크 감소, 발급 대기시간 감소 -> 라이더 만족도 증가
- 개인정보 수집하지 않고 직접 수단을 선택할 수 있도록 했음 (공유하기: 다운로드 등)
  - 열람용 비밀번호 설정
- 라이더의 요청 후 즉시 발급 (직접 원하는 기간을 설정해 발급 대기시간을 최소화)

`프로덕트의 목적`에 Align하여 목표를 설정하자. 운영자가 힘들게 일하면, 그 여파는 서비스 어딘가에는 나타남. 그곳을 찾아서 '서비스'를 개선하자

### 상세 구현/내용 기획

'운영자'가 있다는 점. 니즈가 명확
적어도 3번, 수기 업무 담당 운영자와 만나자
1차, 사용자스토리 및 플로우를 정의할 때
2차, 초안 그림이 나왔을 때
3차, 개발 전 최종 컨펌을 위해

질문의 질문... 꼬리물기 질문으로 집요하게 Edge 케이스를 파고들기

**Case02. 시간제보험료 정산 자동화**
- 배달 시간만큼 보험료를 지불하고 혜택을 적용받는 유상운송용 보험
- 보험료 정책은 3개월마다 바뀌므로 '보험료 관리 어드민'이 필요 (예상하지 못한 개발범위)
- 보험료 정책 유형화 (분단위, 일정액)

'운영자'와 끊임없이 소통하자

### 피드백 분석/후속 대응

사람이 하는 일이니까, 무슨 상황이 터져도 일단 대응 가능하다
- 자동화하면 모르던 이슈가 터져나올 수 있다.

**Case03. 운전면허 검증 자동화**
- 수기로 경찰청 사이트로 검사, 수기로 확인
- 도로교통공단의 허가, 연동해서 자동화 시작
- 운행 시작 시 기등록된 면허로 자동 검증해 무효 시 불가
- 외국인 라이더들의 이름이 너무나 다양함
- 경찰청 서버 점검 기간 동안 운전면허 검증 대응하기, 실물 면허증 재발급 이후 ㅓ버 연동 시까지의 시간차
- 사람이 했다면 업무 상 판단 하에 처리하던 이슈들이 시스템 상에서 안정화 될때까지 신경써야한다.
- 이슈 상황이 발생하거나 정기 점검등으로 라이더의 검증이 불가한 경우, 정보를 입력받은 후 해소 시 일괄 검증
- 배포없이 기능을 on/off 되도록 개선 (flag를 심어둠) - 자동화 on/off

## 4. 이벤트 스토밍 인 액션: 이벤트 스토밍 소개와 적용 방법 - 박재성(Jason) (테크코스교육개발실/클라이언트교육팀)

### 이벤트 스토밍

- 이해관계자들의 용어를 통일한다
- 이를 싱크하기 위해 가지는 자리?

이벤트 스토밍 하는 이유?
- 유사한 용어가 혼용되어 사용되어서
- 도메인 요소의 흐름과 관계를 파악하지 못해서

근본 원인
- 사일로 내부에서만 전문가인 도메인 전문가
- 도메인에 거의 또는 전혀 관심이 없는 동료 개발자(정량적인 것에만 관심)

퍼즐 조각을 모으는데 엄청난 비용 발생


*알베르토 브란돌리니*가 제안 - 복잡한 비즈니스 도메인을 빠르게 탐색하고 학습할 수 있는 워크숍
코드를 없애고 모든 사람을 동일한 수준으로 만드는 접근법

## 워크숍 방법

- 회의실, 종이, 포스트잇(쉽게 떼고 붙일 수 있음), 실제 문제 해결에 관련된 모든 사람(질문이 있는 사람, 답이 있는 사람)
- 퍼실리테이터
  - 이해관계자가 아닌 분
  - 눈앞의 도메인에 대한 이해가 아니라 진행 상황 등을 파악해 워크숍이 원할하게 진행되도록 도와줌
  - 이벤트 스토밍과 도메인 이벤트가 뭔지 설명만 하고 바로 시작
- 진행방법
  - 벽에 커다란 종이를 붙여 놓고 포스트잇을 붙여 나간다
  - 최대 4~5시간이 적당
- 도메인 이벤트
  - 도메인 전문가가 관심이 있는 어떤 사건(과거에 일어났던 일을 표현)
  - 이벤트가 발생한다는 것은 상태가 변경되었다는 것을 의미
  - 글을 조회 한다(이벤트일수도 아닐수도 있음)

1단계
- 각자가 알고있는 도메인 이벤트를 작성한다.
- 16명 팀이면 4~50분 동안 진행됨 (15분 휴식)
  안티패턴(위원회)
- 포스트잇을 붙이기 전에 합의가 이루어지는 것
- 퍼실리테이터는 이를 꺠뜨려야한다.

2단계
- 모든 도메인 이벤트를 올바른 타임라인으로 정렬하고 실제로 중복되는 이벤트를 제거한다.
- 시간은 왼->오, 위->아래로 평행한 시간을 표현
  드라이버와 네비게이터
- 드라이버(잘 알고 있거나 배워야 하는 사람이 좋음): 포스트잇 옮기는 사람
- 네비게이터: 지시 내리는 사람
  안티패턴
- 스포츠카, 자율주행, 스포일러

3단계? 핫스폿
- 2단계에서 발생한 질문, 갈등, 불평, 불만 사항을 시각화하고 캡처함
- 당장 토론하지 않는다. 나중에 문제가 해결되면 제거
- 핫 스팟만 파악돼도 의미있는 워크샵이 됨

바운디드 컨텍스트
- 같은 용어라도 의미가 다르고 같은 대상이라도 지칭 용어가 다를 수 있다.
- 명백한 언어 불일치는 동일한 프로세스 내에서 여러 개의 바운디드 컨텍스트를 나태내는 지표임
- 커피 = 이탈리아 에스프레소/미국 아메리카노

커맨드 또는 액션
- 시스템에서 일어나는 일, 도메인 이벤트가 발생하는 원인

리드 모델 또는 정보
- 사용자가 결정을 내리는 데 필요한 정보
- 특정 정책으로 인해 발생한 도메인 이벤트의 결과가 리드 모델에 어떻게 반영되는지 확인할 수 있다.

정책
- ~할 때마다라는 단어로 시작
- 도메인 이벤트와 커멘드 사이에 위치
- 회원가입 - 웰컴 정책 - 웰컴킷 보내기

비즈니스 규칙(유효성 검사; 시스템이 일관성을 보장해야할 비즈니스 규칙)


팁
- 일정 수준의 기획이 나온 후에 진행하는 것이 좋음
- 프로젝트의 모호한 부분이 많아지면 시간을 낭비할 수 있음 -> 정책 논의로 번짐
- 결과를 문서화할 필요없이 그 경험으로 남겨야 함